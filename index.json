[{"categories":[],"contents":"# 定时器timerfd 相关函数 #include \u0026lt;sys/timerfd.h\u0026gt; int timerfd_create(int clockid, int flags); int timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value); int timerfd_gettime(int fd, struct itimerspec *curr_value); timerfd_create timerfd_create() 创建一个定时器描述付timerfd clockid CLOCK_REALTIME、CLOCK_MONOTONIC flags 为 0 或者 O_NONBLOCK CLOCK_REALTIME //自1970-01-01起经历的秒数、本秒中经历的纳秒数 CLOCK_MONOTONIC //自CPU启动时流逝的时间 timetfd_settime timerfd_settime 用来启动或关闭fd指定的定时器 fd timerfd_create函数返回的定时器文件描述符 flags 1 代表绝对时间，0 为相对时间 new_value 指定新的超时时间 old_value 不为 NULL，则返回定时器这这次设置之前的超时时间 timerfd_gettime timerfd_gettime 这个函数通常是为了检查定时器还有多长时间触发，或者检查定时器是否是一次性的还是周期性的。周期性定时器的it_interval会被设置为非零值，表示每次到期后，定时器会自动重新设置为这个间隔值。如果it_interval为零，则定时器只触发一次。 示例程序 #include \u0026lt;sys/timerfd.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; /* Definition of uint64_t */ #define handle_error(msg) \\ do { printf(msg); exit(EXIT_FAILURE); } while (0) static void print_elapsed_time(void) { static struct timespec start; struct timespec curr; static int first_call = 1; int secs, nsecs; if (first_call) { first_call = 0; if (clock_gettime(CLOCK_MONOTONIC, \u0026amp;start) == -1) handle_error(\u0026#34;clock_gettime\u0026#34;); } if (clock_gettime(CLOCK_MONOTONIC, \u0026amp;curr) == -1) handle_error(\u0026#34;clock_gettime\u0026#34;); secs = curr.tv_sec - start.tv_sec; nsecs = curr.tv_nsec - start.tv_nsec; if (nsecs \u0026lt; 0) { secs--; nsecs += 1000000000; } printf(\u0026#34;%d.%03d: \u0026#34;, secs, (nsecs + 500000) / 1000000); } int main(int argc, char *argv[]) { struct itimerspec new_value; int max_exp, fd; struct timespec now; uint64_t exp, tot_exp; ssize_t s; if ((argc != 2) \u0026amp;\u0026amp; (argc != 4)) { ssize_t s; printf(\u0026#34;%s %d\\n\u0026#34;,__FUNCTION__, __LINE__); if ((argc != 2) \u0026amp;\u0026amp; (argc != 4)) { fprintf(stderr, \u0026#34;%s init-secs [interval-secs max-exp]\\n\u0026#34;, argv[0]); handle_error(\u0026#34;argc argv is error\u0026#34;); } } if (clock_gettime(CLOCK_REALTIME, \u0026amp;now) == -1) { handle_error(\u0026#34;clock_gettime\u0026#34;); } /* Create a CLOCK_REALTIME absolute timer with initial expiration and interval as specified in command line */ new_value.it_value.tv_sec = now.tv_sec + atoi(argv[1]); new_value.it_value.tv_nsec = now.tv_nsec; if (argc == 2) { new_value.it_interval.tv_sec = 0; max_exp = 1; } else { new_value.it_interval.tv_sec = atoi(argv[2]); max_exp = atoi(argv[3]); } new_value.it_interval.tv_nsec = 0; fd = timerfd_create(CLOCK_REALTIME, 0); if (fd == -1) handle_error(\u0026#34;timerfd_create\u0026#34;); if (timerfd_settime(fd, TFD_TIMER_ABSTIME, \u0026amp;new_value, NULL) == -1) handle_error(\u0026#34;timerfd_settime\u0026#34;); print_elapsed_time(); printf(\u0026#34;timer started\\n\u0026#34;); for (tot_exp = 0; tot_exp \u0026lt; max_exp;) { s = read(fd, \u0026amp;exp, sizeof(uint64_t)); if (s != sizeof(uint64_t)) handle_error(\u0026#34;read\u0026#34;); tot_exp += exp; print_elapsed_time(); printf(\u0026#34;read: %llu; total=%llu\\n\u0026#34;, (unsigned long long) exp, (unsigned long long) tot_exp); } exit(EXIT_SUCCESS); } ","date":"2024-05-05T17:35:08+08:00","permalink":"http://brightzi.cn/posts/timerfd-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/","section":"posts","tags":[],"title":"timerfd 相关函数介绍"},{"categories":[],"contents":"问题背景 小组使用C++开发，使用libcurl封装了Http请求模块。由于项目需求实现gzip压缩，便通过libcurl压缩选项实现了该功能。当开启gzip压缩后，短时间内多次发送Http请求，会出现报错“Send failed since rewinding of the data stream failed”。\n问题原因 通过开启debug选项，排查到问题是连接意外断开，当libcurl尝试重新上传数据时，调用自定义的函数 CURLOPT_READFUNCTION， 无法找到原始数据就报错了。\n解决措施 判断code码，当需要重新上传时，重置数据指针： m_sendLength = 0 确保设置了自定义读取函数和数据 curl_easy_setopt(m_handle, CURLOPT_READFUNCTION, read_callback); curl_easy_setopt(m_handle, CURLOPT_READDATA, this); 重新发送数据 curl_easy_perform 示例：\nint retryCount = 0; const int maxRetryCount = 3; // 假设最大重试次数为3 CURLcode res; do { // 重置发送数据的指针 m_sendLength = 0; // 重置其他必要的状态，如读取/写入缓冲区 // 执行CURL请求 res = curl_easy_perform(m_handle); // 根据需要检查特定的错误代码来决定是否重试 if (res == CURLE_OK) { break; // 请求成功，跳出循环 } else { // 处理错误，退出循环/重试 } retryCount++; } while (retryCount \u0026lt; maxRetryCount); ","date":"2024-02-18T23:29:49+08:00","permalink":"http://brightzi.cn/posts/libcurl%E6%8A%A5%E9%94%99-send-failed-since-rewinding-of-the-data-stream-failed/","section":"posts","tags":[],"title":"libcurl报错 \"Send failed since rewinding of the data stream failed\""},{"categories":[],"contents":"编译 1、获取源代码, 下载地址 https://jaist.dl.sourceforge.net/project/libuuid/libuuid-1.0.3.tar.gz\n2、解压文件，创建build文件夹\n3、进入源代码文件下，（交叉编译才需要补充参数）\n./configure \u0026ndash;prefix=/绝对路径/build/ CC=/绝对路径/bin/aarch64-linux-android28-clang \u0026ndash;host=aarch64-linux-android CFLAGS=-I/绝对路径/include\n4、编译 make 再安装 make install\n使用NDK提供的编译器，编译指令：\n./configure --prefix=/src_path/build-android CC=/opt/android-ndk-r25c/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android28-clang CFLAGS=-I/opt/android-ndk-r25c/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --host=aarch64-linux-android 备注 host参数用于指定交叉编译的目标系统的类型，这个参数的值通常是一个三元组（有时被称为 \u0026ldquo;target triplet\u0026rdquo;），它的一般格式为 cpu-vendor-os。这里：\ncpu 表示目标硬件的CPU类型（例如，x86_64、aarch64、arm等）。 vendor 是CPU供应商的名称，但在许多情况下可能被省略或用作泛型名称。 os 表示目标操作系统（例如，linux-android、linux-gnu等）。 对于Android平台，常见的 --host 选项包括：\n对于 ARM 架构：\narm-linux-androideabi：用于32位ARM处理器。 aarch64-linux-android：用于64位ARM处理器（也称为ARM64或ARMv8）。 对于 Intel 架构：\ni686-linux-android：用于32位Intel处理器。 x86_64-linux-android：用于64位Intel处理器。 ","date":"2024-01-31T21:42:12+08:00","permalink":"http://brightzi.cn/posts/libuuid%E7%BC%96%E8%AF%91/","section":"posts","tags":["编译"],"title":"libuuid编译"},{"categories":[],"contents":"unique_ptr C++11引入了std::unique_ptr主要是为了提供一种在资源管理方面更为安全和高效的替代方案。std::unique_ptr是一种独占所有权的智能指针，它确保在程序的生命周期内只有一个指针可以拥有和管理某个资源，通常是动态分配的对象或数组。\nstd::unique_ptr特点： 独占所有权： std::unique_ptr不允许多个指针共享同一个资源，这意味着在任意时刻只有一个unique_ptr可以拥有资源。这有助于防止资源泄漏和难以调试的所有权问题。\n自动资源释放： 当std::unique_ptr的生命周期结束时（例如，离开其作用域），它会自动释放所拥有的资源，无需手动调用delete或delete[]。这有助于避免内存泄漏，并简化了资源管理。\n移动语义： std::unique_ptr支持移动语义，允许资源的高效转移。这使得在函数之间传递std::unique_ptr更为高效，避免了不必要的资源复制。\n定制删除器： 可以通过指定删除器（deleter）来自定义资源的释放行为。这使得std::unique_ptr非常灵活，能够管理各种类型的资源。\nNULL指针检查： std::unique_ptr提供了对空指针的检查，可以帮助避免潜在的运行时错误。\n成员函数及其说明： 构造函数：\nstd::unique_ptr\u0026lt;T\u0026gt;：默认构造函数，创建一个空的 std::unique_ptr。 std::unique_ptr\u0026lt;T\u0026gt;(T* ptr)：接受一个原始指针并拥有它的所有权。 std::unique_ptr\u0026lt;T, Deleter\u0026gt;(T* ptr, Deleter d)：使用指定的删除器创建 std::unique_ptr。 无法进行复制构造和赋值操作，支持移动语义：\nstd::unique_ptr\u0026lt;T\u0026gt;(std::unique_ptr\u0026lt;T\u0026gt;\u0026amp;\u0026amp; other)：移动构造函数，允许将资源的所有权从一个 std::unique_ptr 转移到另一个。 std::unique_ptr\u0026lt;T\u0026gt;\u0026amp; operator=(std::unique_ptr\u0026lt;T\u0026gt;\u0026amp;\u0026amp; other)：移动赋值操作符。 释放资源：\nT* release()：释放对资源的所有权，并返回原始指针。 void reset()：释放当前指针拥有的资源，并将指针置为空。 void reset(T* ptr)：释放当前指针拥有的资源，并接管参数指针的所有权。 获取指针信息：\nT* get()：返回原始指针。 T\u0026amp; operator*()：解引用操作符，返回指向的对象的引用。 T* operator-\u0026gt;()：成员访问操作符，用于通过 std::unique_ptr 访问对象的成员。 检查空指针：\nbool operator==(std::nullptr_t) const noexcept：检查是否为 nullptr。 explicit operator bool() const noexcept：将 std::unique_ptr 转换为布尔值，检查是否拥有资源。 自定义删除器：\ntemplate \u0026lt;class Deleter\u0026gt; std::unique_ptr(T* ptr, Deleter d)：使用自定义删除器创建 std::unique_ptr。 template \u0026lt;class Deleter\u0026gt; Deleter\u0026amp; get_deleter() noexcept：获取当前删除器。 使用示例 创建unique_ptr // 构造方式 std::unique_ptr\u0026lt;int\u0026gt; p1(); std::unique_ptr\u0026lt;int\u0026gt; p2(nullptr); 无法进行复制构造和赋值操作 std::unique_ptr\u0026lt;int\u0026gt; p3(new int); std::unique_ptr\u0026lt;int\u0026gt; p4(p3); std::unique_ptr\u0026lt;int\u0026gt; p5(p3); 支持移动语义 std::unique_ptr\u0026lt;int\u0026gt; p6(new int); std::unique_ptr\u0026lt;int\u0026gt; p7(std::move(p6)); 释放当前资源，设置为空指针 std::unique_ptr\u0026lt;int\u0026gt; p8(new int); std::cout \u0026lt;\u0026lt; \u0026#34;before address: \u0026#34; \u0026lt;\u0026lt; p8.get() \u0026lt;\u0026lt; std::endl; p8.reset(); std::cout \u0026lt;\u0026lt; \u0026#34;after address: \u0026#34; \u0026lt;\u0026lt; p8.get() \u0026lt;\u0026lt; std::endl; 输出\nbefore address: 0x2588030 after address: 0 解引用 std::unique_ptr\u0026lt;int\u0026gt; p9(new int(6)); std::cout \u0026lt;\u0026lt; \u0026#34;*p9 = \u0026#34; \u0026lt;\u0026lt; *p9 \u0026lt;\u0026lt; std::endl; 输出\n*p9 = 6 释放资源的所有权，返回原始指针的引用 std::unique_ptr\u0026lt;int\u0026gt; p10(new int(10)); int *p11 = p10.release(); std::cout \u0026lt;\u0026lt; \u0026#34;*p11 = \u0026#34; \u0026lt;\u0026lt; *p11 \u0026lt;\u0026lt; std::endl; shared_ptr 每个shared_ptr都有一个关联的计数值，通常称为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。 例如，当用一个shared_ptr初始化另一个shred_ptr，或将它当做参数传递给一个函数以及作为函数的返回值时，它 所关联的计数器就会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的 shared_ptr离开其作用域）时，计数器就会递减。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理 的对象。 成员函数线程安全，非成员函数线程不安全。成员函数线程安全通过std::atomic::fetch_add with std::memory_order_relaxed 来实现。\nstd::shared_ptr std::shared_ptr特点： 共享所有权： std::shared_ptr 允许多个智能指针共享同一个资源，通过引用计数来追踪资源的所有权。当最后一个指向资源的 std::shared_ptr 被销毁或重置时，资源才会被释放。\n引用计数： std::shared_ptr 内部维护了一个引用计数，用于记录有多少个智能指针共享同一个资源。引用计数通过原子操作进行增加和减少，从而确保在多线程环境下的安全性。\n弱引用支持： std::shared_ptr 配合 std::weak_ptr 提供了弱引用的支持，可以用于解决循环引用的问题，避免内存泄漏。\n自动释放资源： 当最后一个拥有资源的 std::shared_ptr 被销毁时，它会自动释放所拥有的资源，无需手动调用 delete。\n空指针检查： 提供了安全的空指针检查，避免了访问空指针的运行时错误。\n主要成员函数 构造函数：\nstd::shared_ptr\u0026lt;T\u0026gt;()：默认构造函数，创建一个空的 std::shared_ptr。 std::shared_ptr\u0026lt;T\u0026gt;(T* ptr)：接受一个原始指针并拥有它的所有权。 std::shared_ptr\u0026lt;T\u0026gt;(const std::shared_ptr\u0026lt;T\u0026gt;\u0026amp; other)：复制构造函数，共享资源。 std::shared_ptr\u0026lt;T\u0026gt;(std::nullptr_t)：创建一个空的 std::shared_ptr。 引用计数相关：\nlong use_count() const noexcept：返回当前共享资源的引用计数。 bool unique() const noexcept：检查是否是唯一拥有资源的 std::shared_ptr。 移动语义：\nstd::shared_ptr\u0026lt;T\u0026gt;(std::shared_ptr\u0026lt;T\u0026gt;\u0026amp;\u0026amp; other)：移动构造函数，将资源的所有权从一个 std::shared_ptr 转移到另一个。 赋值操作符：\nstd::shared_ptr\u0026lt;T\u0026gt;\u0026amp; operator=(const std::shared_ptr\u0026lt;T\u0026gt;\u0026amp; other)：复制赋值操作符，共享资源。 std::shared_ptr\u0026lt;T\u0026gt;\u0026amp; operator=(std::shared_ptr\u0026lt;T\u0026gt;\u0026amp;\u0026amp; other)：移动赋值操作符。 获取指针信息：\nT* get()：返回原始指针。 T\u0026amp; operator*()：解引用操作符，返回指向的对象的引用。 T* operator-\u0026gt;()：成员访问操作符，用于通过 std::shared_ptr 访问对象的成员。 空指针检查：\nbool operator==(std::nullptr_t) const noexcept：检查是否为 nullptr。 explicit operator bool() const noexcept：将 std::shared_ptr 转换为布尔值，检查是否拥有资源。 自定义删除器：\ntemplate \u0026lt;class Deleter\u0026gt; std::shared_ptr(T* ptr, Deleter d)：使用自定义删除器创建 std::shared_ptr。 template \u0026lt;class Deleter\u0026gt; Deleter\u0026amp; get_deleter() noexcept：获取当前删除器。 创建实例 通过make_shared 或者 new 来构造实例\nshared_ptr\u0026lt;int\u0026gt; p1 = make_shared\u0026lt;int\u0026gt;(12345); cout \u0026lt;\u0026lt; \u0026#34;p1: \u0026#34; \u0026lt;\u0026lt; *p1 \u0026lt;\u0026lt; endl; shared_ptr\u0026lt;int\u0026gt; p2(new int(23456)); cout \u0026lt;\u0026lt; \u0026#34;p2: \u0026#34; \u0026lt;\u0026lt; *p2 \u0026lt;\u0026lt; endl; new 和 make_shared的区别： new方法在堆上创建了两块内存：1：存储int。2：控制块上用于引用计数的内存，管理附加此内存的 shared_ptr 对象的计数，最初计数将为1。 std::make_shared 一次性为int对象和用于引用计数的数据都分配了内存，而new操作符只是为int分配了内存。\n性能差异：\n性能： std::make_shared 的性能可能更好，因为它可以一次性分配内存来存储对象和控制块，减少了额外的动态内存分配。 异常安全性： std::make_shared 在分配内存时提供了强烈的异常安全性，因为它只有在成功分配了所有内存时才会构造对象。而直接使用构造函数可能在分配内存后抛出异常，导致资源泄漏。 通过拷贝构造初始化，会增加引用计数值 shared_ptr\u0026lt;int\u0026gt; p2(new int(23456)); cout \u0026lt;\u0026lt; \u0026#34;p2: \u0026#34; \u0026lt;\u0026lt; *p2 \u0026lt;\u0026lt; endl; shared_ptr\u0026lt;int\u0026gt; p3(p2); cout \u0026lt;\u0026lt; \u0026#34;p2: \u0026#34; \u0026lt;\u0026lt; p2.use_count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p3: \u0026#34; \u0026lt;\u0026lt; p3.use_count() \u0026lt;\u0026lt; endl; 当share_ptr实例p和实例q，指向相同的类型，通过赋值操作 p = q ,会减少 p 的引用计数， 增加 q 的引用计数。 class Example { public: Example(const char *name) : e(1) { cout \u0026lt;\u0026lt; \u0026#34;Example Constructor...\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; } ~Example() { cout \u0026lt;\u0026lt; \u0026#34;Example Destructor...\u0026#34; \u0026lt;\u0026lt; endl; } int e; }; int main() { shared_ptr\u0026lt;Example\u0026gt; p4(new Example(\u0026#34;a\u0026#34;)); shared_ptr\u0026lt;Example\u0026gt; p5(new Example(\u0026#34;b\u0026#34;)); cout \u0026lt;\u0026lt; \u0026#34;p4: \u0026#34; \u0026lt;\u0026lt; p4.use_count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p5: \u0026#34; \u0026lt;\u0026lt; p5.use_count() \u0026lt;\u0026lt; endl; p4 = p5; cout \u0026lt;\u0026lt; \u0026#34;p4: \u0026#34; \u0026lt;\u0026lt; p4.use_count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p5: \u0026#34; \u0026lt;\u0026lt; p5.use_count() \u0026lt;\u0026lt; endl; } 输出：\nExample Constructor...a Example Constructor...b p4: 1 p5: 1 Example Destructor... p4: 2 p5: 2 Example Destructor... 检查引用计数 调用use_count返回引用计数值 shared_ptr\u0026lt;int\u0026gt; p3(p2); cout \u0026lt;\u0026lt; \u0026#34;p2: \u0026#34; \u0026lt;\u0026lt; p2.use_count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p3: \u0026#34; \u0026lt;\u0026lt; p3.use_count() \u0026lt;\u0026lt; endl; ","date":"2024-01-17T00:00:44+08:00","permalink":"http://brightzi.cn/posts/c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","section":"posts","tags":["C++"],"title":"【C++】智能指针"},{"categories":[],"contents":"一、静态库和动态库 Linux的库文件一般分为静态库和动态库：\n静态库(.a)： 库文件以.a为后缀，程序在编译链接的时候把库的代码链接到可执行文件中。程序运行的时候将不再需要静态库 动态库(.so): 库文件以.so为后缀，程序运行的时候才会去链接动态库的代码，多个程序共享使用库的代码\n二、理解库 如果不想给对方我们的源代码，我们可以选择给用户提供我们的.o可重定位目标二进制文件（gcc -c 文件）与.h头文件。让用户用我们提供的.o文件进行链接即可。在编译时，只要把源文件编译成.o文件在将其链接便可形成一个可执行的程序：\n通过 gcc -o 链接目标文件，生成可执行程序： 我们可以把 .o 和 .h 文件提交给用户，可是如果有成百上千个，那一个个提供太过麻烦。因此为了让用户简单的使用库，我们就把所有 .o文件打包成一个包，给对方提供一个库文件即可。把多个文件合并成一个文件，这个文件就是库，打包的方式就分为了静态库和动态库。\n三、制作静态库 创建Makefile\nlibmymath.a: my_add.o my_sub.o ar -rc $@ $^ my_add.o: my_add.c gcc -c my_add.c -o my_add.o my_sub.o: my_sub.c gcc -c my_sub.c -o my_sub.o .PHONY: output output: mkdir -p mylib/include mkdir -p mylib/lib cp -f *.a mylib/lib cp -f *.h mylib/include .PHONY: clean clean: rm -rf *.o libmymath.a 在Makefile中，$@和$^是自动变量，用于表示规则中的目标和依赖项。\n$@表示当前规则的目标（target），即规则左侧的文件名。 $^表示当前规则的所有依赖项（prerequisites），即规则右侧的文件名。 在Makefile中，libmymath.a: my_add.o my_sub.o规则中的 $@ 表示 libmymath.a，即目标文件名。$^ 表示 my_add.o my_sub.o，即所有依赖项的列表。\n当执行命令时，$@和$^会被替换为实际的目标和依赖项的文件名，以便进行相关操作。例如，ar -rc $@ $^ 中的 $@ 将被替换为 libmymath.a，$^ 将被替换为 my_add.o my_sub.o。因此，该命令最终将执行 ar -rc libmymath.a my_add.o my_sub.o，将 my_add.o 和 my_sub.o 打包成 libmymath.a 静态库。\noutput 是我们要生成的库 链接库：\ngcc -o mytest my_test.c -I ./mylib/include -L ./mylib/lib -lmymath -I:指明头文件的搜索路径\n-L:指明库文件的搜索路径\n-l:指明要链接哪个库，带上库的名称（去掉前缀和后缀）\n四、制作动态库 首先我们需要把库文件全部编译成.o文件，这里与静态库不同，需要带上选项 -fPIC,形成与位置无关码：\ngcc -c -fPIC my_add.c 动态库打包：-shared\ngcc -shared -o libmymath.so my_add.o my_sub.o 目录结构：\n➜ test tree . ├── libmymath.so ├── Makefile ├── my_add.c ├── my_add.h ├── my_add.o ├── mylib │ ├── include │ │ ├── my_add.h │ │ └── my_sub.h │ └── lib │ └── libmymath.so ├── my_sub.c ├── my_sub.h ├── my_sub.o ├── mytest └── my_test.c 链接动态库：\ngcc -o mytest my_test.c -I mylib/include -L mylib/lib -lmymath 报错了： 我们此时已经告诉了库文件，路径和库名称，选项已经给gcc带上了。但是我们当编译完之后，和gcc还有关系吗？答案是无关的，接下来运行是和OS有关的，动态库是运行时才加载的，所以程序运行起来，OS和shell也是需要知道库是在哪里的！而我们自己制作的库并没有在系统路径下，OS无法找到！如何找到动态库。\n把库路径添加到环境变量LD_LIBRARY_PATH：\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/zmm/playground/test/mylib/lib ","date":"2024-01-16T23:17:25+08:00","permalink":"http://brightzi.cn/posts/c%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/","section":"posts","tags":["编译"],"title":"静态链接和动态链接"},{"categories":[],"contents":"C++状态机\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;string\u0026gt; enum class PaymentEvent { PAY_CREATE, PAY_PROCESS, PAY_SUCCESS, PAY_FAIL }; class PaymentStatus { public: // 枚举状态 enum Status { INIT, PAYING, PAID, FAILED }; // 构造函数 PaymentStatus(Status status, const std::string\u0026amp; description) : status(status), description(description) {} // 获取目标状态 static Status getTargetStatus(Status sourceStatus, PaymentEvent event); // 打印状态信息 void printStatus() const { std::cout \u0026lt;\u0026lt; \u0026#34;Status: \u0026#34; \u0026lt;\u0026lt; description \u0026lt;\u0026lt; std::endl; } private: Status status; std::string description; }; // 自定义哈希函数 namespace std { template \u0026lt;\u0026gt; struct hash\u0026lt;std::pair\u0026lt;PaymentStatus::Status, PaymentEvent\u0026gt;\u0026gt; { size_t operator()(const std::pair\u0026lt;PaymentStatus::Status, PaymentEvent\u0026gt;\u0026amp; p) const { // 一种简单的哈希组合方法 return std::hash\u0026lt;int\u0026gt;()(static_cast\u0026lt;int\u0026gt;(p.first)) ^ std::hash\u0026lt;int\u0026gt;()(static_cast\u0026lt;int\u0026gt;(p.second)); } }; } // 静态映射表，存储状态转换 std::unordered_map\u0026lt;std::pair\u0026lt;PaymentStatus::Status, PaymentEvent\u0026gt;, PaymentStatus::Status\u0026gt; stateTransitions = { {{PaymentStatus::INIT, PaymentEvent::PAY_CREATE}, PaymentStatus::PAYING}, {{PaymentStatus::PAYING, PaymentEvent::PAY_PROCESS}, PaymentStatus::PAID}, {{PaymentStatus::PAYING, PaymentEvent::PAY_FAIL}, PaymentStatus::FAILED} // 添加其他状态转换 }; // 获取目标状态的静态方法实现 PaymentStatus::Status PaymentStatus::getTargetStatus(Status sourceStatus, PaymentEvent event) { auto it = stateTransitions.find({sourceStatus, event}); if (it != stateTransitions.end()) { return it-\u0026gt;second; } else { return sourceStatus; // 默认情况下保持原状态 } } int main() { PaymentStatus paymentStatusInit(PaymentStatus::INIT, \u0026#34;初始化\u0026#34;); PaymentStatus paymentStatusPaying(PaymentStatus::PAYING, \u0026#34;支付中\u0026#34;); PaymentStatus paymentStatusPaid(PaymentStatus::PAID, \u0026#34;支付成功\u0026#34;); PaymentStatus paymentStatusFailed(PaymentStatus::FAILED, \u0026#34;支付失败\u0026#34;); paymentStatusInit.printStatus(); PaymentStatus::Status newStatus = PaymentStatus::getTargetStatus(PaymentStatus::INIT, PaymentEvent::PAY_CREATE); paymentStatusPaying = PaymentStatus(newStatus, \u0026#34;支付中\u0026#34;); paymentStatusPaying.printStatus(); return 0; } ","date":"2024-01-16T19:24:11+08:00","permalink":"http://brightzi.cn/posts/%E7%8A%B6%E6%80%81%E6%9C%BA/","section":"posts","tags":["C++"],"title":"状态机"},{"categories":null,"contents":"CC=gcc CXX=g++ AR=ar ARFLAGS=rcs NGINX_VERSION = 1.16.1 NGINX_OBJS_PATH = /root/github/nginx-$(NGINX_VERSION)/objs NGINX_SRC_PATH = /root/github/nginx-$(NGINX_VERSION)/src CFLAGS = -pipe -g -W -Wall -fPIC \\ -I $(NGINX_OBJS_PATH) \\ -I $(NGINX_SRC_PATH)/core \\ -I $(NGINX_SRC_PATH)/event \\ -I $(NGINX_SRC_PATH)/event/modules \\ -I $(NGINX_SRC_PATH)/os/unix \\ -I $(NGINX_SRC_PATH)/http \\ -I $(NGINX_SRC_PATH)/http/modules \\ -I $(NGINX_SRC_PATH)/mail \\ -I $(NGINX_SRC_PATH)/stream \\ NGINX_LDFLAGS = -lpcre -lcrypto -lcrypt -lz -lpthread LDFLAGS = -L . -lnginx $(NGINX_LDFLAGS) NGINX_ROOT = /root/github/nginx-$(NGINX_VERSION) NGINX_MAKEFILE = $(NGINX_ROOT)/Makefile NGINX_TAR = $(NGINX_ROOT).tar.gz NGINX_OBJS = \\ objs/src/core/nginx.o \\ objs/src/core/ngx_log.o \\ objs/src/core/ngx_palloc.o \\ objs/src/core/ngx_array.o \\ objs/src/core/ngx_list.o \\ objs/src/core/ngx_hash.o \\ objs/src/core/ngx_buf.o \\ objs/src/core/ngx_queue.o \\ objs/src/core/ngx_output_chain.o \\ objs/src/core/ngx_string.o \\ objs/src/core/ngx_parse.o \\ objs/src/core/ngx_parse_time.o \\ objs/src/core/ngx_inet.o \\ objs/src/core/ngx_file.o \\ objs/src/core/ngx_crc32.o \\ objs/src/core/ngx_murmurhash.o \\ objs/src/core/ngx_md5.o \\ objs/src/core/ngx_sha1.o \\ objs/src/core/ngx_rbtree.o \\ objs/src/core/ngx_radix_tree.o \\ objs/src/core/ngx_slab.o \\ objs/src/core/ngx_times.o \\ objs/src/core/ngx_shmtx.o \\ objs/src/core/ngx_connection.o \\ objs/src/core/ngx_cycle.o \\ objs/src/core/ngx_spinlock.o \\ objs/src/core/ngx_rwlock.o \\ objs/src/core/ngx_cpuinfo.o \\ objs/src/core/ngx_conf_file.o \\ objs/src/core/ngx_module.o \\ objs/src/core/ngx_resolver.o \\ objs/src/core/ngx_open_file_cache.o \\ objs/src/core/ngx_crypt.o \\ objs/src/core/ngx_proxy_protocol.o \\ objs/src/core/ngx_syslog.o \\ objs/src/event/ngx_event.o \\ objs/src/event/ngx_event_timer.o \\ objs/src/event/ngx_event_posted.o \\ objs/src/event/ngx_event_accept.o \\ objs/src/event/ngx_event_udp.o \\ objs/src/event/ngx_event_connect.o \\ objs/src/event/ngx_event_pipe.o \\ objs/src/os/unix/ngx_time.o \\ objs/src/os/unix/ngx_errno.o \\ objs/src/os/unix/ngx_alloc.o \\ objs/src/os/unix/ngx_files.o \\ objs/src/os/unix/ngx_socket.o \\ objs/src/os/unix/ngx_recv.o \\ objs/src/os/unix/ngx_readv_chain.o \\ objs/src/os/unix/ngx_udp_recv.o \\ objs/src/os/unix/ngx_send.o \\ objs/src/os/unix/ngx_writev_chain.o \\ objs/src/os/unix/ngx_udp_send.o \\ objs/src/os/unix/ngx_udp_sendmsg_chain.o \\ objs/src/os/unix/ngx_channel.o \\ objs/src/os/unix/ngx_shmem.o \\ objs/src/os/unix/ngx_process.o \\ objs/src/os/unix/ngx_daemon.o \\ objs/src/os/unix/ngx_setaffinity.o \\ objs/src/os/unix/ngx_setproctitle.o \\ objs/src/os/unix/ngx_posix_init.o \\ objs/src/os/unix/ngx_user.o \\ objs/src/os/unix/ngx_dlopen.o \\ objs/src/os/unix/ngx_process_cycle.o \\ objs/src/os/unix/ngx_linux_init.o \\ objs/src/event/modules/ngx_epoll_module.o \\ objs/src/os/unix/ngx_linux_sendfile_chain.o \\ objs/src/core/ngx_regex.o \\ objs/src/http/ngx_http.o \\ objs/src/http/ngx_http_core_module.o \\ objs/src/http/ngx_http_special_response.o \\ objs/src/http/ngx_http_request.o \\ objs/src/http/ngx_http_parse.o \\ objs/src/http/modules/ngx_http_log_module.o \\ objs/src/http/ngx_http_request_body.o \\ objs/src/http/ngx_http_variables.o \\ objs/src/http/ngx_http_script.o \\ objs/src/http/ngx_http_upstream.o \\ objs/src/http/ngx_http_upstream_round_robin.o \\ objs/src/http/ngx_http_file_cache.o \\ objs/src/http/ngx_http_write_filter_module.o \\ objs/src/http/ngx_http_header_filter_module.o \\ objs/src/http/modules/ngx_http_chunked_filter_module.o \\ objs/src/http/modules/ngx_http_range_filter_module.o \\ objs/src/http/modules/ngx_http_gzip_filter_module.o \\ objs/src/http/ngx_http_postpone_filter_module.o \\ objs/src/http/modules/ngx_http_ssi_filter_module.o \\ objs/src/http/modules/ngx_http_charset_filter_module.o \\ objs/src/http/modules/ngx_http_userid_filter_module.o \\ objs/src/http/modules/ngx_http_headers_filter_module.o \\ objs/src/http/ngx_http_copy_filter_module.o \\ objs/src/http/modules/ngx_http_not_modified_filter_module.o \\ objs/src/http/modules/ngx_http_static_module.o \\ objs/src/http/modules/ngx_http_autoindex_module.o \\ objs/src/http/modules/ngx_http_index_module.o \\ objs/src/http/modules/ngx_http_mirror_module.o \\ objs/src/http/modules/ngx_http_try_files_module.o \\ objs/src/http/modules/ngx_http_auth_basic_module.o \\ objs/src/http/modules/ngx_http_access_module.o \\ objs/src/http/modules/ngx_http_limit_conn_module.o \\ objs/src/http/modules/ngx_http_limit_req_module.o \\ objs/src/http/modules/ngx_http_geo_module.o \\ objs/src/http/modules/ngx_http_map_module.o \\ objs/src/http/modules/ngx_http_split_clients_module.o \\ objs/src/http/modules/ngx_http_referer_module.o \\ objs/src/http/modules/ngx_http_rewrite_module.o \\ objs/src/http/modules/ngx_http_proxy_module.o \\ objs/src/http/modules/ngx_http_fastcgi_module.o \\ objs/src/http/modules/ngx_http_uwsgi_module.o \\ objs/src/http/modules/ngx_http_scgi_module.o \\ objs/src/http/modules/ngx_http_memcached_module.o \\ objs/src/http/modules/ngx_http_empty_gif_module.o \\ objs/src/http/modules/ngx_http_browser_module.o \\ objs/src/http/modules/ngx_http_upstream_hash_module.o \\ objs/src/http/modules/ngx_http_upstream_ip_hash_module.o \\ objs/src/http/modules/ngx_http_upstream_least_conn_module.o \\ objs/src/http/modules/ngx_http_upstream_random_module.o \\ objs/src/http/modules/ngx_http_upstream_keepalive_module.o \\ objs/src/http/modules/ngx_http_upstream_zone_module.o \\ objs/ngx_modules.o OBJS_WITH_PERFIX:=$(addprefix $(NGINX_ROOT)/, $(NGINX_OBJS)) LIBNGINX_STATIC = libnginx.a all:$(LIBNGINX_STATIC) $(LIBNGINX_STATIC) : $(OBJS_WITH_PERFIX) $(AR) $(ARFLAGS) $@ $(OBJS_WITH_PERFIX) clean: rm -rf $(LIBNGINX_STATIC) ","date":"0001-01-01T00:00:00Z","permalink":"http://brightzi.cn/posts/linux-%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91-libnginx.a/","section":"posts","tags":null,"title":""},{"categories":null,"contents":"SIGKILL和SIGSTOP不可被忽略，内核和超级用户可进行程序\n","date":"0001-01-01T00:00:00Z","permalink":"http://brightzi.cn/posts/unix%E4%BF%A1%E5%8F%B7/","section":"posts","tags":null,"title":""},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"http://brightzi.cn/search/","section":"","tags":null,"title":"Search"},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"http://brightzi.cn/archives/","section":"","tags":null,"title":"归档"}]